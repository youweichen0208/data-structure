[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "data-structure",
    "section": "",
    "text": "Sliding Window\n\n\n\n\n\n\n\nsliding window\n\n\ncode\n\n\nJava\n\n\n\n\n\n\n\n\n\n\n\nNov 27, 2023\n\n\nYouwei Chen\n\n\n\n\n\n\n  \n\n\n\n\nDynamic Programming\n\n\n\n\n\n\n\ndynamic programming\n\n\ncode\n\n\nJava\n\n\n\n\n\n\n\n\n\n\n\nNov 27, 2023\n\n\nYouwei Chen\n\n\n\n\n\n\n  \n\n\n\n\ncheatsheet\n\n\n\n\n\n\n\ncheatsheet\n\n\n\n\n\n\n\n\n\n\n\nNov 27, 2023\n\n\nYouwei Chen\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nNov 24, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/dp/index.html",
    "href": "posts/dp/index.html",
    "title": "Dynamic Programming",
    "section": "",
    "text": "1. What exactly is DP?\nIn short, dynamic programming is optimized recursion. The arguments that a recursive function takes represents a state. When we looked at tree problems, we never visited a node more than once in our DFS, which means that a state can be repeated, usually an exponential number of times. To avoid repeating computation, we use something called memoization. When we find the answer (the return value) for a given state, we cache that value(usually in hashmap). Then in the future, if we ever see the same state again, we can just refer to the cached value without the needing to re-calculate it.\n\n\n2. Top-down vs. bottom-up\n\nTop-down:\nwe start from the top(the original problem) and move down toward the base case. For example, we wanted the nth Fibonacci number, so we started by calling fibonacci(n). We move down with recursion until we reach the base cases (F(0) and F(1)).\n\n\nBottom-up:\nIn bottom-up, we start at the bottom (base cases) and work our way up to larger problems.\n\n\n\n3. When should I consider using DP?\n\nThe problem will be asking for an optimal value (max or min) of something or the number of ways to do something.\n\nWhat is the minimum cost of doing…\nWhat is the maximum profit of …\nHow many ways are there to …\nWhat is the longest possible …\n\nAt each step, you need to make a “decision”, and decisions affect future decisions.\n\nA decision could be picking two elements\nDecisions affecting future decisions could be something like “if you take an element x, then you can’t take an element y in the future”\n\n\n\n\n4. Framework for DP:\n\nA function or data structure that will compute/contain the answer to the problem for any given state.\nA recurrence relation to transition between states.\nBase cases"
  },
  {
    "objectID": "posts/dfs/index.html",
    "href": "posts/dfs/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/sliding window/index.html",
    "href": "posts/sliding window/index.html",
    "title": "Sliding Window",
    "section": "",
    "text": "1. When should we use sliding window?\n\nthe problem will either explicitly or implicitly define criteria that make a subarray “valid”:\n\nconstraint metric: asking for attributes of a subarray. It could be the sum, the number of unique elements, the frequency of a specific element, or any other attribute.\na numeric restriction on the constraint metric. This is what the constraint metric should be for a subarray to be considered valid.\n\nthe problem will ask you to find valid subarrays in some way.\n\nthe most common task you will see is finding the best valid subarray. The problem will define what makes a subarray better than another. For example, a problem might ask you to find the longest valid subarray.\nanother common task is finding the number of valid subarrays.\n\n\n\n\n2. pseudocode for a general template:\nfunction fn(arr):\n    left = 0\n    for (int right = 0; right &lt; arr.length; right++):\n        Do some logic to \"add\" element at arr[right] to window\n\n        while WINDOW_IS_INVALID:\n            Do some logic to \"remove\" element at arr[left] from window\n            left++\n        Do some logic to update the answer"
  },
  {
    "objectID": "posts/cheatsheet/dfs/index.html",
    "href": "posts/cheatsheet/dfs/index.html",
    "title": "cheatsheet",
    "section": "",
    "text": "1. StringBuilder:\n\nappend in StringBuilder:\nThe append() method appends the provided data to the end of StringBuilder. We can chain multiple append() calls together to build a string step by step.\nStringBuilder sb = new StringBuilder();\nsb.append(\"Hello, \");\nsb.append('W');\nsb.append(42);\n\n\ninsert in StringBuilder:\ninsert() is used to insert data at a specific position within the StringBuilder. It’s also overloaded and accepts various data types\npublic class MyClass {\n    public static void main(String args[]) {\n      StringBuilder builder = new StringBuilder(\"xyz\");\n      builder.insert(1, 100);\n      System.out.println(\"Builder is \" + builder.toString()); //Builder is x100yz\n    }\n}\n\n\nsetCharAt:\nuse the setCharAt() method in the StringBuilder class to modify a character at specified index within the StringBuilder.\nStringBuilder sb = new StringBuilder(\"Hello, World!\");\n\n// Set the character at index 7 to 'X'\nsb.setCharAt(7, 'X');\n\n// sb now contains \"Hello, Xorld!\"\n\n\ndelete():\nthis method removes a range of characters from the StringBuilder.\nStringBuilder sb = new StringBuilder(\"Hello, World!\");\nsb.delete(7, 13); // Removes \"World!\"\n\n\ndeleteCharAt():\nThis method removes the character at a specified index.\nStringBuilder sb = new StringBuilder(\"Hello, World!\");\nsb.deleteCharAt(5); // Removes ','\n\n\nreplace():\nthis method replaces a range of characters with a specified string.\nStringBuilder sb = new StringBuilder(\"Hello, World!\");\nsb.replace(0, 5, \"Hi\"); // Replaces \"Hello\" with \"Hi\"\n\n\nsubstring():\nthis method extracts a substring from the StringBuilder based on start and end indices.\nStringBuilder sb = new StringBuilder(\"Hello, World!\");\nString substring = sb.substring(7, 12); // Retrieves \"World\"\n\n\nreverse():\nthis method reverses the characters in the StringBuilder in place.\nStringBuilder sb = new StringBuilder(\"Hello\");\nsb.reverse(); //Now sb contains \"olleH\"\n\n\nlength():\nthis method returns the current length (number of characters) of the StringBuilder.\nStringBuilder sb = new StringBuilder(\"Hello, World!\");\nint length = sb.length(); // Returns 13\n\n\n\n2. Converting Number to String:\n\nUsing String.valueOf():\nYou can convert a number (e.g., int, double, float, etc.) to a string using the String.valueOf() method or by simply concatenating it with an empty string (““).\nint number = 42;\nString str = String.valueOf(number); // or str = \"\" + number;\n\n\n\n3. Converting String to Number:\n\nUsing Integer.valueOf():\nTo convert a string to an integer, we can use the Integer.parseInt() method. This method parses the string and returns an integer.\n\n\nUsing Double.valueOf():\nFor converting strings to floating-point numbers, we can use the Double.parseDouble method.\n\n\n\n4. Arrays.sort():\nArrays.sort() is a method in Java that is used to sort elements in an array in ascending order. It’s part of the java.util package and is commonly used for sorting arrays of various types, including arrays of primitive data types and arrays of objects.\n\nSorting Arrays of Primitive Data Types:\nint[] numbers = {5, 2, 9, 1, 5, 6};\nArrays.sort(numbers); // Sorts the 'numbers' array in ascending order\n\n\nCustom Comparator for Objects:\nString[] words = {\"apple\", \"banana\", \"cherry\", \"date\"};\nArrays.sort(words, (a, b) -&gt; Integer.compare(a.length(), b.length()));\n// Sorts 'words' by string length\n\n\n\n5. Collections.sort:\nCollections.sort() is a method in Java used to sort elements in a collection in ascending order. Unlike Arrays.sort(), which is used to sort arrays, Collections.sort() is used with collections that implement the List interface.\n\nSorting Lists of Objects:\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nList&lt;String&gt; names = new ArrayList&lt;&gt;();\nnames.add(\"Alice\");\nnames.add(\"Bob\");\nnames.add(\"Charlie\");\nnames.add(\"Eve\");\n\nCollections.sort(names); // Sorts the 'names' list in lexicographical (alphabetical) order\n\n\nCustom Comparator for Lists of Objects:\nList&lt;String&gt; words = new ArrayList&lt;&gt;();\nwords.add(\"apple\");\nwords.add(\"banana\");\nwords.add(\"cherry\");\nwords.add(\"date\");\n\nCollections.sort(words, (a, b) -&gt; Integer.compare(a.length(), b.length()));\n// Sorts 'words' by string length\n\n\n\n6.Common Methods in HashMap in Java:\n\ncontainsKey(key):\nchecks if the map contains a specific key. Returns true if the key exists.\nboolean exists = map.containsKey(\"apple\"); // Checks if the key \"apple\" exists\n\n\ncontainsValue(value):\nchecks if the map contains a specific value. Return true if the value exists.\nboolean exists = map.containsValue(5); // Checks if the value 5 exists in the map\n\n\nremove(key):\nremoves a key-value pair from the map based on the specified key.\nmap.remove(\"apple\"); // Removes the key-value pair with the key \"apple\"\n\n\nsize():\nreturns the number of key-value pairs in the map\nint size = map.size(); // Returns the number of entries in the map\n\n\nisEmpty():\nchecks if the map is empty. Returns true if the map has no key-value pairs.\nboolean isEmpty = map.isEmpty(); // Checks if the map is empty\n\n\niterate through hashmap:\nIn Java, we can iterate through a HashMap using a for-each loop on the entrySet of the map. Here’s an example:\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n\n        // Add key-value pairs to the HashMap\n        map.put(\"Apple\", 10);\n        map.put(\"Banana\", 20);\n        map.put(\"Cherry\", 30);\n\n        // Iterate over the HashMap\n        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {\n            System.out.println(\"Key: \" + entry.getKey() + \", Value: \" + entry.getValue());\n        }\n    }\n}\n\n\niterate through keys:\nIn Java, we can iterate through keys in hashmap as well using keySet()\nMap&lt;Integer, Integer&gt; counts = new HashMap&lt;&gt;();\nfor (int key : counts.keySet()){\n\n}\n\n\nget the value or the default value in HashMap:\nThe getOrDefault(Object key, V defaultValue) method of HashMap in Java is used to get the value to which the specified key is mapped, or the defaultValue if this map contains no mapping for the key\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n        map.put(\"Apple\", 10);\n        map.put(\"Banana\", 20);\n\n        int defaultValue = 0;\n        int appleCount = map.getOrDefault(\"Apple\", defaultValue);\n        int orangeCount = map.getOrDefault(\"Orange\", defaultValue);\n\n        System.out.println(\"Apple Count: \" + appleCount);  // Output: Apple Count: 10\n        System.out.println(\"Orange Count: \" + orangeCount);  // Output: Orange Count: 0\n    }\n}\n\n\n\n7. HashSet in Java:\nA HashSet in Java is a collection of items where every item is unique, and it is one of the implementations of the Set interface. HashSet does not maintain any order of its elements. It uses the hashCode method of the objects it contains to efficiently store its elements and ensure uniqueness.\n\nmethods in Hashset:\n\nadd(E e): add the specified element to this set if it is not present.\nremove(Object o): removes the specified element from this set if it is present\ncontains(Object o): returns true if this set contains the specified element.\nsize(): returns the number of elements in this set.\nisEmpty(): returns true if this set contains no elements.\nclear(): removes all of the elements from this set.\n\n\n\ninitialization:\n\nwe can initialize a HashSet without the parameter:\n\nHashSet&lt;String&gt; set = new HashSet&lt;&gt;();\n\nwe can also initialize a HashSet with a list or collection to the HashSet. This can be useful for removing duplicates from a list or an array, since a HashSet does not allow duplicate elements.\n\nString[] array = {\"Apple\", \"Banana\", \"Apple\", \"Cherry\"};\nHashSet&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(array));\n\nSystem.out.println(set);  // Output: [Apple, Cherry, Banana]\n\n\n\n8. Stacks in Java:\nA stack is an ordered collection of elements where elements are only added and removed from the same end.\n\nmethods in stack:\n\npush(E item): pushes an item onto top of this stack.\npop(): removes the object at the top of this stack and returns that object as the value of this function.\npeek(): looks at the object at the top of this stack without removing it from the stack.\nempty(): test if this stack is empty.\nsearch(Object o): returns the 1-based position where an object is on this stack.\n\n\n\nstack initialization:\nStack&lt;String&gt; stack = new Stack&lt;&gt;();\n\n\n\n9. Queue in Java:\n\nmethods in queue:\n\nadd(E e): inserts specific element into this queue if it is possible to do so immediately without violating the restrictions.\noffer(E e): inserts the specified element into this queue if it is possible to do.\nremove(): retrieves and removes the head of this queue.\npoll(): retrieves and remove the head of this queue, or return null if this queue is empty.\npeek(): retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.\n\n\n\ninitialization in queue:\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n    public static void main(String[] args) {\n        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(\"Apple\");\n        queue.add(\"Banana\");\n        queue.add(\"Cherry\");\n\n        System.out.println(queue.peek());  // Output: Apple\n        System.out.println(queue.poll());  // Output: Apple\n        System.out.println(queue.peek());  // Output: Banana\n    }\n}\n\n\n\n10. Math in java\n\nMath.ceil():\nMath.ceil() is a floating-point number up to the nearest integer using the Math.ceil() method\npublic class CeilingExample {\n    public static void main(String[] args) {\n        double number1 = 4.2;\n        double number2 = 7.8;\n        double number3 = -3.14;\n\n        double result1 = Math.ceil(number1);\n        double result2 = Math.ceil(number2);\n        double result3 = Math.ceil(number3);\n\n        System.out.println(\"Math.ceil(4.2) = \" + result1); // Output: 5.0\n        System.out.println(\"Math.ceil(7.8) = \" + result2); // Output: 8.0\n        System.out.println(\"Math.ceil(-3.14) = \" + result3); // Output: -3.0\n    }\n}"
  }
]